---
# SPDX-License-Identifier: EUPL-1.2
# SPDX-FileCopyrightText: 2025-present JÃ¼rgen MÃ¼lbert <juergen.muelbert@gmail.com>

name: Continuous Delivery

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
  release:
    types: [published]
  issues:
    types: [closed]
  schedule:
    - cron: 30 8 * * *

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  notify-release:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: ðŸ”’ Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: ðŸ“ Notify release
        uses: nearform-actions/github-action-notify-release@1a1c03a2b8c9a41a7a88f9a8de05b2b6582f0966 # v1.12.2

      - name: Create release with filtered changelog
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Helper: check if commit message starts with allowed prefixes
            function isMeaningfulCommit(message) {
              const prefixes = ['break', 'feat', 'fix', 'perf', 'refactor', ];
              const lowerMsg = message.toLowerCase();
              return prefixes.some(prefix => lowerMsg.startsWith(prefix));
            }

            // Get the latest release
            let latestRelease;
            try {
              latestRelease = await github.rest.repos.getLatestRelease({ owner, repo });
            } catch (error) {
              if (error.status === 404) {
                core.info('No previous release found, treating as first release.');
              } else {
                throw error;
              }
            }

            const latestTag = latestRelease?.data.tag_name || null;
            core.info(`Latest release tag: ${latestTag || 'none'}`);

            // Get commits since the latest release tag or recent commits if none
            let commits;
            if (latestTag) {
              // Get the commit date of the latest tag
              const latestTagCommit = await github.rest.repos.getCommit({
                owner,
                repo,
                ref: latestTag,
              });
              const latestTagDate = latestTagCommit.data.commit.author.date;

              // List commits on default branch since latest tag date
              commits = await github.paginate(
                github.rest.repos.listCommits,
                {
                  owner,
                  repo,
                  sha: context.payload.repository.default_branch,
                  since: latestTagDate,
                }
              );
            } else {
              // No previous release, get last 30 commits on default branch
              commits = await github.rest.repos.listCommits({
                owner,
                repo,
                sha: context.payload.repository.default_branch,
                per_page: 30,
              }).then(res => res.data);
            }

            // Filter commits by message prefix
            const filteredCommits = commits.filter(c => {
              const message = c.commit.message.split('\n')[0];
              return isMeaningfulCommit(message);
            });

            if (filteredCommits.length === 0) {
              core.info('No meaningful commits since last release.');
              return;
            }

            // Generate changelog lines from filtered commits
            const changelogLines = filteredCommits.map(c => {
              const shortSha = c.sha.substring(0, 7);
              const message = c.commit.message.split('\n')[0];
              return `- ${message} (${shortSha})`;
            });

            const changelog = changelogLines.join('\n');

            // Get new tag from the ref that triggered the workflow
            const newTag = context.ref.replace('refs/tags/', '');
            core.info(`Creating release for tag: ${newTag}`);

            // Create the release
            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: newTag,
              name: newTag,
              body: `## Changelog\n\n${changelog}`,
              draft: false,
              prerelease: false,
            });

            core.info('Release created successfully.');
